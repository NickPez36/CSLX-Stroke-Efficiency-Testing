<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing Data Loader</title>
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <!-- 3. Chart.js Zoom Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for split data */
        .split-data-list {
            display: flex;
            overflow-x: auto;
            padding-bottom: 1rem;
            white-space: nowrap;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: thin; /* Firefox */
        }
        .split-data-list::-webkit-scrollbar {
            height: 8px;
        }
        .split-data-list::-webkit-scrollbar-track {
            background: #f1f5f9; /* gray-100 */
            border-radius: 10px;
        }
        .split-data-list::-webkit-scrollbar-thumb {
            background: #94a3b8; /* gray-400 */
            border-radius: 10px;
        }
        .split-data-list::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* gray-500 */
        }
        /* Simple spinner */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Styling for active toggle button */
        .toggle-btn-active {
            background-color: #3b82f6; /* blue-600 */
            color: white;
        }
        .toggle-btn-inactive {
            background-color: #e5e7eb; /* gray-200 */
            color: #4b5563; /* gray-600 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 antialiased">

    <!-- Main Container -->
    <div class="max-w-7xl mx-auto p-4 md:p-8">
        
        <header class="mb-8">
            <h1 class="text-4xl font-bold text-gray-800">Canoe Slalom Performance Dashboard</h1>
        </header>

        <main>
            <!-- 1. Data Selection -->
            <div class="bg-gray-50 p-6 rounded-lg shadow-inner mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold text-gray-800">Data Selection</h2>
                    <button id="add-comparison-btn" class="text-sm text-blue-600 hover:text-blue-800 font-medium">
                        + Add Comparison
                    </button>
                    <button id="remove-comparison-btn" class="hidden text-sm text-red-600 hover:text-red-800 font-medium">
                        - Remove Comparison
                    </button>
                </div>
                
                <div id="loader-area" class="flex items-center space-x-2 text-gray-600 hidden">
                    <div class="spinner"></div>
                    <span id="loader-text">Loading...</span>
                </div>
                
                <!-- File A Selection -->
                <div id="selection-ui-a" class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div>
                        <label for="athlete-select-a" class="block text-sm font-medium text-gray-700">1. Select Athlete (File A)</label>
                        <select id="athlete-select-a" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div>
                        <label for="date-select-a" class="block text-sm font-medium text-gray-700">2. Select Date (File A)</label>
                        <select id="date-select-a" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Select athlete first</option>
                        </select>
                    </div>
                    <div>
                        <label for="file-select-a" class="block text-sm font-medium text-gray-700">3. Select Trial (File A)</label>
                        <select id="file-select-a" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Select date first</option>
                        </select>
                    </div>
                    <div class="self-end">
                        <button id="load-data-btn" class="mt-1 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition disabled:bg-gray-300" disabled>
                            Load Data
                        </button>
                    </div>
                </div>

                <!-- File B Selection -->
                <div id="selection-ui-b" class="hidden grid grid-cols-1 md:grid-cols-4 gap-4 mt-4 pt-4 border-t border-gray-300">
                    <div>
                        <label for="athlete-select-b" class="block text-sm font-medium text-gray-700">1. Select Athlete (File B)</label>
                        <select id="athlete-select-b" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div>
                        <label for="date-select-b" class="block text-sm font-medium text-gray-700">2. Select Date (File B)</label>
                        <select id="date-select-b" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Select athlete first</option>
                        </select>
                    </div>
                    <div>
                        <label for="file-select-b" class="block text-sm font-medium text-gray-700">3. Select Trial (File B)</label>
                        <select id="file-select-b" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Select date first</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Message/Error Area -->
            <div id="message-area" class="hidden mt-6 p-4 rounded-lg"></div>

            <!-- File Info Display -->
            <div id="file-info-container" class="hidden mt-8"></div>

            <!-- Key Metrics -->
            <div id="metrics-container" class="hidden mt-8"></div>

            <!-- Performance Chart -->
            <div id="chart-container" class="hidden mt-8">
                <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-4">
                    <h2 class="text-2xl font-semibold text-gray-800">Performance Chart</h2>
                    <div id="chart-toggles" class="hidden mt-2 sm:mt-0 space-x-2">
                        <button id="chart-toggle-velocity" class="toggle-btn-active px-4 py-2 text-sm font-medium rounded-lg">Velocity</button>
                        <button id="chart-toggle-acceleration" class="toggle-btn-inactive px-4 py-2 text-sm font-medium rounded-lg">Acceleration</button>
                    </div>
                    <button id="reset-zoom-btn" class="mt-2 sm:mt-0 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition text-sm">
                        Reset Zoom
                    </button>
                </div>
                <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
                    <canvas id="velocity-chart"></canvas>
                </div>
            </div>

            <!-- Split Analysis -->
            <div id="split-analysis-container" class="hidden mt-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Split Analysis (100m)</h2>
                <div id="split-accordion" class="space-y-2"></div>
            </div>

        </main>
    </div>

    <!-- JavaScript -->
    <script>
        // Global chart instances
        let velocityChartInstance = null;
        let splitChartInstances = new Map();

        // Global state for analysis data
        let analysisData = { a: null, b: null };
        let activeChartMetric = 'velocity';

        // GitHub API Constants
        const GH_USER = 'NickPez36';
        const GH_REPO = 'CSLX-Stroke-Efficiency-Testing';
        const API_BASE_URL = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/contents/`;
        const DATA_PATH = 'data';

        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const messageArea = document.getElementById('message-area');
            const fileInfoContainer = document.getElementById('file-info-container');
            const metricsContainer = document.getElementById('metrics-container');
            const chartContainer = document.getElementById('chart-container');
            const resetZoomBtn = document.getElementById('reset-zoom-btn');
            const splitAnalysisContainer = document.getElementById('split-analysis-container');
            const loaderArea = document.getElementById('loader-area');
            const loaderText = document.getElementById('loader-text');
            const loadDataBtn = document.getElementById('load-data-btn');
            const addComparisonBtn = document.getElementById('add-comparison-btn');
            const removeComparisonBtn = document.getElementById('remove-comparison-btn');
            const selectionUiB = document.getElementById('selection-ui-b');
            const chartToggles = document.getElementById('chart-toggles');
            const chartToggleVelocity = document.getElementById('chart-toggle-velocity');
            const chartToggleAcceleration = document.getElementById('chart-toggle-acceleration');

            const getSelectElements = (suffix) => ({
                athlete: document.getElementById(`athlete-select-${suffix}`),
                date: document.getElementById(`date-select-${suffix}`),
                file: document.getElementById(`file-select-${suffix}`)
            });

            // --- UI Event Listeners ---
            addComparisonBtn.addEventListener('click', () => {
                selectionUiB.classList.remove('hidden');
                addComparisonBtn.classList.add('hidden');
                removeComparisonBtn.classList.remove('hidden');
                loadDataBtn.textContent = "Load Comparison";
                loadAthletes('b');
            });

            removeComparisonBtn.addEventListener('click', () => {
                selectionUiB.classList.add('hidden');
                addComparisonBtn.classList.remove('hidden');
                removeComparisonBtn.classList.add('hidden');
                loadDataBtn.textContent = "Load Data";
                analysisData.b = null;
                if (analysisData.a) displayUI();
            });

            chartToggleVelocity.addEventListener('click', () => {
                activeChartMetric = 'velocity';
                chartToggleVelocity.classList.replace('toggle-btn-inactive', 'toggle-btn-active');
                chartToggleAcceleration.classList.replace('toggle-btn-active', 'toggle-btn-inactive');
                drawMetricsChart();
            });

            chartToggleAcceleration.addEventListener('click', () => {
                activeChartMetric = 'acceleration';
                chartToggleAcceleration.classList.replace('toggle-btn-inactive', 'toggle-btn-active');
                chartToggleVelocity.classList.replace('toggle-btn-active', 'toggle-btn-inactive');
                drawMetricsChart();
            });

            resetZoomBtn.addEventListener('click', () => {
                if (velocityChartInstance) velocityChartInstance.resetZoom();
            });

            document.addEventListener('click', (e) => {
                const target = e.target.closest('[data-accordion-toggle]');
                if (target) {
                    const contentId = target.getAttribute('data-accordion-target');
                    const content = document.getElementById(contentId);
                    const icon = target.querySelector('svg');
                    if (content) {
                        content.classList.toggle('hidden');
                        icon.classList.toggle('rotate-180');
                        content.querySelectorAll('canvas').forEach(canvas => {
                            const canvasId = canvas.id;
                            if (canvasId && !splitChartInstances.has(canvasId)) {
                                const chartData = JSON.parse(canvas.dataset.chartData);
                                drawSplitChart(canvasId, chartData.labels, chartData.datasets, chartData.unit, chartData.isBandChart); // Pass isBandChart
                            }
                        });
                    }
                }
            });

            // --- GitHub API Functions ---
            const showLoader = (text) => { loaderText.textContent = text; loaderArea.classList.remove('hidden'); };
            const hideLoader = () => loaderArea.classList.add('hidden');

            async function handleApiError(response, error) {
                let errorMsg = 'Failed to load data from GitHub. Check console.';
                if (error) console.error('GitHub API Error:', error);
                else if (response) {
                    console.error(`GitHub API Error: ${response.status} ${response.statusText}`);
                    errorMsg += ` Status: ${response.status}.`;
                    if (response.status === 404) errorMsg += ' Not Found.';
                    else if (response.status === 403) errorMsg += ' Rate Limit Exceeded.';
                }
                showMessage('error', errorMsg); hideLoader();
            }

            async function fetchApi(url) {
                const response = await fetch(url);
                if (!response.ok) { await handleApiError(response); return null; }
                return response.json();
            }

            async function loadAthletes(suffix = 'a') {
                showLoader('Loading athletes...');
                const selects = getSelectElements(suffix);
                const data = await fetchApi(API_BASE_URL + DATA_PATH);
                if (!data) return;
                const athleteFolders = data.filter(item => item.type === 'dir').sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically
                selects.athlete.innerHTML = '<option value="">Select athlete</option>';
                athleteFolders.forEach(folder => selects.athlete.add(new Option(folder.name, folder.name)));
                selects.athlete.disabled = false;
                hideLoader();
            }

            async function loadDates(athleteName, suffix = 'a') {
                const selects = getSelectElements(suffix);
                if (!athleteName) return;
                showLoader(`Loading dates for ${athleteName}...`);
                selects.date.innerHTML = '<option value="">Select date</option>'; selects.date.disabled = true;
                selects.file.innerHTML = '<option value="">Select date first</option>'; selects.file.disabled = true;
                if (suffix === 'a') loadDataBtn.disabled = true;
                const path = `${DATA_PATH}/${encodeURIComponent(athleteName)}`;
                const data = await fetchApi(API_BASE_URL + path);
                if (!data) return;
                const dateFolders = data.filter(item => item.type === 'dir' && /^\d{8}$/.test(item.name)).sort((a, b) => b.name.localeCompare(a.name)); // Sort descending
                dateFolders.forEach(folder => selects.date.add(new Option(folder.name, folder.name)));
                selects.date.disabled = false;
                hideLoader();
            }

            async function loadFiles(athleteName, dateFolder, suffix = 'a') {
                const selects = getSelectElements(suffix);
                if (!dateFolder) return;
                showLoader(`Loading files for ${dateFolder}...`);
                selects.file.innerHTML = '<option value="">Select trial</option>'; selects.file.disabled = true;
                if (suffix === 'a') loadDataBtn.disabled = true;
                const path = `${DATA_PATH}/${encodeURIComponent(athleteName)}/${encodeURIComponent(dateFolder)}`;
                const data = await fetchApi(API_BASE_URL + path);
                if (!data) return;
                const files = data.filter(item => item.type === 'file' && item.name.endsWith('.csv')).sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically
                files.forEach(file => {
                    const option = new Option(file.name, file.name);
                    option.dataset.url = file.download_url;
                    selects.file.add(option);
                });
                selects.file.disabled = false;
                hideLoader();
            }

            async function loadAndAnalyzeFile(suffix) {
                const selects = getSelectElements(suffix);
                const selectedOption = selects.file.selectedOptions[0];
                if (!selectedOption || !selectedOption.dataset.url) return null;
                const fileName = selectedOption.value;
                const downloadUrl = selectedOption.dataset.url;
                showLoader(`Loading ${fileName}...`);
                try {
                    const response = await fetch(downloadUrl);
                    if (!response.ok) { await handleApiError(response); return null; }
                    const csvString = await response.text();
                    const fileInfo = parseFileInfo(fileName, suffix);
                    const csvData = parseCSV(csvString);
                    const chartData = prepareChartData(csvData.headers, csvData.data);
                    const metricsResult = calculateAllMetrics(chartData.velocityData, chartData.timeData, fileInfo.trial, chartData);
                    return { fileInfo, chartData, ...metricsResult };
                } catch (error) {
                    showMessage('error', `Failed to analyze ${fileName}: ${error.message}`); console.error(error); return null;
                }
            }

            async function handleLoadData() {
                loadDataBtn.disabled = true; showMessage('info', 'Loading data...');
                analysisData.a = await loadAndAnalyzeFile('a');
                analysisData.b = selectionUiB.classList.contains('hidden') ? null : await loadAndAnalyzeFile('b');
                if (analysisData.a) { showMessage('success', 'Data loaded.'); displayUI(); }
                else showMessage('error', 'Failed to load File A.');
                hideLoader(); loadDataBtn.disabled = false;
            }

            // Dropdown Event Listeners
            getSelectElements('a').athlete.addEventListener('change', (e) => loadDates(e.target.value, 'a'));
            getSelectElements('a').date.addEventListener('change', (e) => loadFiles(getSelectElements('a').athlete.value, e.target.value, 'a'));
            getSelectElements('a').file.addEventListener('change', () => { loadDataBtn.disabled = !getSelectElements('a').file.value; });
            getSelectElements('b').athlete.addEventListener('change', (e) => loadDates(e.target.value, 'b'));
            getSelectElements('b').date.addEventListener('change', (e) => loadFiles(getSelectElements('b').athlete.value, e.target.value, 'b'));
            loadDataBtn.addEventListener('click', handleLoadData);

            // --- Master Display Function ---
            function displayUI() {
                fileInfoContainer.innerHTML = ''; metricsContainer.innerHTML = '';
                const accordion = splitAnalysisContainer.querySelector('#split-accordion');
                if (accordion) accordion.innerHTML = '';

                if (analysisData.b) { // Comparison Mode
                    chartToggles.classList.remove('hidden'); resetZoomBtn.classList.remove('hidden');
                    displayComparisonFileInfo(); displayComparisonMetrics(); displayComparisonSplits();
                } else if (analysisData.a) { // Single File Mode
                    chartToggles.classList.add('hidden'); resetZoomBtn.classList.remove('hidden');
                    displaySingleFileInfo(); displaySingleMetrics(); displaySingleSplits();
                } else { // No Data
                    fileInfoContainer.classList.add('hidden'); metricsContainer.classList.add('hidden');
                    chartContainer.classList.add('hidden'); splitAnalysisContainer.classList.add('hidden');
                    return;
                }
                fileInfoContainer.classList.remove('hidden'); metricsContainer.classList.remove('hidden');
                splitAnalysisContainer.classList.remove('hidden');
                drawMetricsChart(); chartContainer.classList.remove('hidden');
            }

            // --- Start application ---
            loadAthletes('a');

            // --- Parsing Functions ---
            function parseFileInfo(filename, suffix = 'a') {
                const regex = /^(\d{8})_(\d{6})_([^_]+)_([^_]+)_(\w+)$/;
                const match = filename.replace('.csv', '').match(regex);
                const selects = getSelectElements(suffix);
                if (!match) {
                    console.warn(`Filename format error: ${filename}. Using dropdowns.`);
                    const athlete = selects.athlete.value, date = selects.date.value, trial = filename.replace('.csv', '');
                    if (athlete && date) {
                        const dateStr = `${date.substring(0, 4)}-${date.substring(4, 6)}-${date.substring(6, 8)}`;
                        const nameParts = athlete.split(' ');
                        const firstName = nameParts[0] || '', lastName = nameParts.slice(1).join(' ') || '';
                        return { date: dateStr, time: "N/A", lastName, firstName, trial, // (NEW) Add descriptive label
                                 descriptiveLabel: `${firstName} ${lastName} - ${dateStr} - ${trial}` }; 
                    } throw new Error("Filename format error & missing info.");
                }
                const [_, date, time, lastName, firstName, trial] = match;
                const formattedDate = `${date.substring(0, 4)}-${date.substring(4, 6)}-${date.substring(6, 8)}`;
                return { date: formattedDate, time: `${time.substring(0, 2)}:${time.substring(2, 4)}:${time.substring(4, 6)}`, lastName, firstName, trial, 
                         descriptiveLabel: `${firstName} ${lastName} - ${formattedDate} - ${trial}` };
            }

            function parseCSV(csvString, headerRow = 29) {
                const rows = csvString.split(/\r?\n/);
                if (rows.length < headerRow + 1) throw new Error(`File < ${headerRow + 1} rows.`);
                const headers = rows[headerRow - 1].split(',').map(h => h.trim());
                const data = rows.slice(headerRow).map(r => r.split(',').map(d => d.trim())).filter(row => row.length >= headers.length && row[0] !== '');
                if (data.length === 0) throw new Error("No data rows found. Check headers on row 29.");
                return { headers, data };
            }

            // --- Helper Functions ---
            function simpleMovingAverage(data, windowSize) {
                const smoothed = new Array(data.length).fill(null); if (windowSize <= 0) return data; let sum = 0;
                for (let i = 0; i < data.length; i++) { sum += data[i]; if (i >= windowSize) { sum -= data[i - windowSize]; smoothed[i] = sum / windowSize; } else if (i === windowSize - 1) smoothed[i] = sum / windowSize; } return smoothed;
            }
            function cumulativeMovingAverage(data) { let sum = 0; return data.map((v, i) => { sum += v; return sum / (i + 1); }); }

            // (NEW) Velocity Band Calculation
            function calculateVelocityBand(velocities, smoothingWindow) {
                if (!velocities || velocities.length < smoothingWindow + 10) return { avgPeak: null, avgTrough: null, avgBand: null }; // Return nulls if not enough data
                const smoothed = simpleMovingAverage(velocities, smoothingWindow).filter(v => v !== null);
                if (smoothed.length < 2) return { avgPeak: null, avgTrough: null, avgBand: null };
                
                const avgSmoothedVel = smoothed.reduce((a, b) => a + b, 0) / smoothed.length;
                let strokeCycles = [], currentCycle = { startIndex: -1 }; // Initialize startIndex to -1
                let wasBelowAverage = true;

                for (let i = 0; i < smoothed.length; i++) {
                    if (smoothed[i] > avgSmoothedVel && wasBelowAverage) {
                        if (currentCycle.startIndex !== -1) { // Check if a cycle has started
                            currentCycle.endIndex = i;
                            strokeCycles.push(currentCycle);
                        }
                        currentCycle = { startIndex: i };
                        wasBelowAverage = false;
                    } else if (smoothed[i] < avgSmoothedVel) {
                        wasBelowAverage = true;
                    }
                }
                if (currentCycle.startIndex !== -1 && !currentCycle.endIndex && currentCycle.startIndex < smoothed.length -1) {
                     currentCycle.endIndex = smoothed.length - 1;
                     strokeCycles.push(currentCycle);
                }

                let peaks = [], troughs = [], bands = [];
                for (const cycle of strokeCycles) {
                    const cycleData = velocities.slice(cycle.startIndex, cycle.endIndex + 1); 
                    if (cycleData.length < 2) continue;
                    const peak = Math.max(...cycleData); const peakIndex = cycleData.indexOf(peak);
                    const troughData = cycleData.slice(peakIndex + 1);
                    if (troughData.length > 0) { const trough = Math.min(...troughData); peaks.push(peak); troughs.push(trough); bands.push(peak - trough); }
                }

                if (bands.length === 0) return { avgPeak: null, avgTrough: null, avgBand: null };
                const avgPeak = peaks.reduce((a, b) => a + b, 0) / peaks.length;
                const avgTrough = troughs.reduce((a, b) => a + b, 0) / troughs.length;
                const avgBand = bands.reduce((a, b) => a + b, 0) / bands.length;
                return { avgPeak, avgTrough, avgBand };
            }

            // --- Charting Functions ---
            function prepareChartData(headers, data) {
                const distanceInterval = 0.02; const secondsIndex = headers.findIndex(h => h.toLowerCase() === 'seconds'); if (secondsIndex === -1) throw new Error("'Seconds' column not found.");
                const labels = [], vels = [], accels = [], times = [];
                data.forEach((row, i) => { const time = parseFloat(row[secondsIndex]); if (!isNaN(time) && time > 0) { const dist = (i + 1) * distanceInterval, vel = distanceInterval / time; labels.push(dist.toFixed(2)); vels.push(vel); times.push(time); accels.push(i > 0 && vels[i - 1] !== null ? (vel - vels[i - 1]) / time : 0); } else { labels.push(null); vels.push(null); times.push(null); accels.push(null); } });
                const valid = vels.map((v, i) => v !== null ? i : -1).filter(i => i !== -1);
                if (valid.length === 0) throw new Error("No valid data.");
                return { labels: valid.map(i => labels[i]), velocityData: valid.map(i => vels[i]), accelerationData: cumulativeMovingAverage(valid.map(i => accels[i])), timeData: valid.map(i => times[i]) };
            }

            function drawMetricsChart() { 
                const ctx = document.getElementById('velocity-chart').getContext('2d');
                if (velocityChartInstance) velocityChartInstance.destroy();
                let datasets = []; const dataA = analysisData.a, dataB = analysisData.b;
                // (UPDATED) Use descriptive labels from fileInfo
                const labelA = dataA.fileInfo.descriptiveLabel; 
                const labelB = dataB ? dataB.fileInfo.descriptiveLabel : '';

                if (dataB) { 
                    if (activeChartMetric === 'velocity') { 
                        datasets = [ 
                            { label: labelA, data: dataA.smoothedVelocities.map(v => v ? v.toFixed(2) : null), borderColor: '#3b82f6', yAxisID: 'y-velocity', tension: 0.1, pointRadius: 1, fill: false }, 
                            { label: labelB, data: dataB.smoothedVelocities.map(v => v ? v.toFixed(2) : null), borderColor: '#ef4444', yAxisID: 'y-velocity', tension: 0.1, pointRadius: 1, fill: false } 
                        ]; 
                    } else { 
                        datasets = [ 
                            { label: labelA, data: dataA.chartData.accelerationData.map(a => a ? a.toFixed(2) : null), borderColor: '#3b82f6', yAxisID: 'y-acceleration', tension: 0.4, pointRadius: 1, fill: false }, 
                            { label: labelB, data: dataB.chartData.accelerationData.map(a => a ? a.toFixed(2) : null), borderColor: '#ef4444', yAxisID: 'y-acceleration', tension: 0.4, pointRadius: 1, fill: false } 
                        ]; 
                    } 
                } else if (dataA) { 
                    datasets = [ 
                        { label: 'Smoothed Velocity (m/s)', data: dataA.smoothedVelocities.map(v => v ? v.toFixed(2) : null), borderColor: '#3b82f6', yAxisID: 'y-velocity', tension: 0.1, pointRadius: 1, fill: false }, 
                        { label: `Acceleration (m/s²)`, data: dataA.chartData.accelerationData.map(a => a ? a.toFixed(2) : null), borderColor: '#ec4899', yAxisID: 'y-acceleration', tension: 0.4, pointRadius: 1, fill: false } 
                    ]; 
                }
                velocityChartInstance = new Chart(ctx, { type: 'line', data: { labels: dataA.chartData.labels, datasets: datasets }, options: { responsive: true, maintainAspectRatio: true, interaction: { mode: 'index', intersect: false }, scales: { x: { title: { display: true, text: 'Distance (m)' } }, 'y-velocity': { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Velocity (m/s)', color: '#3b82f6' }, beginAtZero: true }, 'y-acceleration': { type: 'linear', display: true, position: 'right', title: { display: true, text: 'Acceleration (m/s²)', color: '#ec4899' }, grid: { drawOnChartArea: false } } }, plugins: { legend: { display: !!dataB }, tooltip: { mode: 'index', intersect: false, callbacks: { title: (items) => `Dist: ${items[0].label} m` } }, zoom: { pan: { enabled: true, mode: 'x' }, zoom: { wheel: { enabled: false }, pinch: { enabled: false }, drag: { enabled: true, mode: 'x' } } } } } });
            }

            function drawSplitChart(canvasId, labels, datasets, dataUnit, isBandChart = false) {
                const ctx = document.getElementById(canvasId); if (!ctx) return;
                let yMin = 0, yMax = 1;
                const allData = datasets.flatMap(ds => ds.data).filter(v => v !== null && isFinite(v));
                if (allData.length > 0) { const dataMin = Math.min(...allData), dataMax = Math.max(...allData); const padding = (dataMax - dataMin) * 0.1, finalPadding = padding === 0 ? (dataMax === 0 ? 1 : dataMax * 0.1) : padding; yMin = dataMin - finalPadding; yMax = dataMax + finalPadding; if (dataMin >= 0 && yMin < 0) yMin = 0; }
                
                let chartDatasets;
                if (isBandChart) {
                    chartDatasets = datasets.map((ds, index) => ({
                        label: ds.label, data: ds.data,
                        borderColor: ds.color || (index === 0 ? '#3b82f6' : '#ef4444'), 
                        pointRadius: 1, borderWidth: 1, tension: 0.1,
                        // (UPDATED) Fill logic for potentially 4 datasets [A_peak, A_trough, B_peak, B_trough]
                        fill: ds.isTrough ? (index === 1 ? 0 : (index === 3 ? 2: false)) : false, 
                        backgroundColor: ds.isTrough ? (index === 1 ? 'rgba(59, 130, 246, 0.2)' : (index === 3 ? 'rgba(239, 68, 68, 0.2)' : 'transparent')) : 'transparent' 
                    }));
                } else {
                    chartDatasets = datasets.map(ds => ({ label: ds.label, data: ds.data, fill: false, borderColor: ds.color || '#3b82f6', borderWidth: 2, tension: 0.1, pointRadius: 4, pointHoverRadius: 6, pointBackgroundColor: ds.color || '#3b82f6' }));
                }

                const chart = new Chart(ctx, { type: 'line', data: { labels, datasets: chartDatasets }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { min: yMin, max: yMax, title: { display: true, text: dataUnit } }, x: { ticks: { font: { size: 10 } } } }, plugins: { legend: { display: datasets.length > 1 }, tooltip: { callbacks: { title: (items) => `Split: ${items[0].label}` } } }, spanGaps: true } });
                splitChartInstances.set(canvasId, chart);
            }

            // --- Metrics Calculation ---
            function calculateSegmentMetrics(velocities, times, smoothingWindow) {
                // Return structure now includes: strokeCount, peakVelocity, averageVelocity, totalTime, strokeRate, eWPS, strokeLength, avgBand, avgPeak, avgTrough
                if (!velocities || velocities.length === 0 || !times || times.length === 0 || velocities.length !== times.length) return { strokeCount: 0, peakVelocity: 0, averageVelocity: 0, totalTime: 0, strokeRate: 0, eWPS: 0, strokeLength: 0, avgBand: null, avgPeak: null, avgTrough: null };
                
                const smoothed = simpleMovingAverage(velocities, smoothingWindow).filter(v => v !== null);
                let strokeCount = 0; if (smoothed.length > 0) { const avgSmooth = smoothed.reduce((a, b) => a + b, 0) / smoothed.length; let wasBelow = true; for (const v of smoothed) { if (v > avgSmooth && wasBelow) { strokeCount++; wasBelow = false; } else if (v < avgSmooth) wasBelow = true; } }
                
                let peakV = 0, sumV = 0; velocities.forEach(v => { if (v > peakV) peakV = v; sumV += v; });
                const totalT = times.reduce((a, b) => a + b, 0); const avgV = velocities.length > 0 ? sumV / velocities.length : 0;
                let sr = 0, ewps = 0, sl = 0; const dist = velocities.length * 0.02;
                if (totalT > 0 && strokeCount > 0) sr = (strokeCount / totalT) * 60;
                if (sr > 0) ewps = (avgV ** 3) / (sr / 60);
                if (strokeCount > 0) sl = dist / strokeCount;
                
                const { avgPeak, avgTrough, avgBand } = calculateVelocityBand(velocities, smoothingWindow);

                return { strokeCount, peakVelocity: peakV, averageVelocity: avgV, totalTime: totalT, strokeRate: sr, eWPS: ewps, strokeLength: sl, avgBand, avgPeak, avgTrough };
            }

            function calculateAllMetrics(velocities, times, trialName, chartData) {
                const distPerPoint = 0.02; const smoothWin = (trialName.toUpperCase() === "MAX") ? 10 : 20;
                const splitMetrics = []; const splits = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]; let startR = 0, startM = 0;
                
                for (let i = 0; i < splits.length; i++) {
                    const endM = splits[i]; const endR = Math.round(endM / distPerPoint);
                    const segVels = velocities.slice(startR, endR); const segTimes = times.slice(startR, endR);
                    let segMetrics = calculateSegmentMetrics(segVels, segTimes, smoothWin);
                    // (NEW) Nullify band metrics for 0-10m
                    if (i === 0) { segMetrics.avgBand = null; segMetrics.avgPeak = null; segMetrics.avgTrough = null; } 
                    splitMetrics.push({ label: `${startM}m - ${endM}m`, metrics: segMetrics });
                    startR = endR; startM = endM; if (startR >= velocities.length) break;
                }

                let totalSC = 0, totalT = 0; splitMetrics.forEach(s => { totalSC += s.metrics.strokeCount; totalT += s.metrics.totalTime; });
                
                let peakV = 0, sumV = 0; velocities.forEach(v => { if (v > peakV) peakV = v; sumV += v; });
                const avgV = velocities.length > 0 ? sumV / velocities.length : 0;
                let totalSR = 0, totalEWPS = 0, totalSL = 0; const totalDist = velocities.length * distPerPoint;
                if (totalT > 0 && totalSC > 0) totalSR = (totalSC / totalT) * 60;
                if (totalSR > 0) totalEWPS = (avgV ** 3) / (totalSR / 60);
                if (totalSC > 0) totalSL = totalDist / totalSC;

                // (NEW) Calculate total band excluding 0-10m
                const startIndex10m = Math.round(10 / distPerPoint);
                const bandVels = velocities.slice(startIndex10m);
                const totalBandMetrics = calculateVelocityBand(bandVels, smoothWin);

                const totalMetrics = { strokeCount: totalSC, peakVelocity: peakV, averageVelocity: avgV, totalTime: totalT, strokeRate: totalSR, eWPS: totalEWPS, strokeLength: totalSL, avgBand: totalBandMetrics.avgBand };
                
                return { metrics: totalMetrics, splitMetrics, smoothedVelocities: simpleMovingAverage(chartData.velocityData, smoothWin), smoothWin };
            }
            
            function pivotSplitData(splitMetrics) {
                const labels = splitMetrics.map(s => s.label);
                const metricData = { totalTime: { label: "Split Time", unit: "s", data: [] }, averageVelocity: { label: "Average Velocity", unit: "m/s", data: [] }, peakVelocity: { label: "Peak Velocity", unit: "m/s", data: [] }, strokeCount: { label: "Strokes", unit: "strokes", data: [] }, strokeRate: { label: "Stroke Rate", unit: "spm", data: [] }, strokeLength: { label: "Stroke Length", unit: "m", data: [] }, 
                // (UPDATED) Include raw peak/trough for band chart construction
                avgBand: { label: "Velocity Band", unit: "m/s", data: [], isBandChart: true }, avgPeak: { data: [] }, avgTrough: { data: [] },
                eWPS: { label: "eWPS", unit: "", data: [] } };
                for (const split of splitMetrics) { for (const key in metricData) { if(split.metrics[key] !== undefined) metricData[key].data.push(split.metrics[key]); } }
                // No need to create datasets here anymore, handled in display function
                return { labels, metrics: metricData };
            }

            // --- Display Functions ---
            function showMessage(type, text) { messageArea.innerHTML = text; messageArea.className = `mt-6 p-4 rounded-lg ${type === 'error' ? 'bg-red-100 text-red-700' : type === 'success' ? 'bg-green-100 text-green-700' : 'bg-blue-100 text-blue-700'}`; }
            function displaySingleFileInfo() { const info = analysisData.a.fileInfo; fileInfoContainer.innerHTML = `<h2 class="text-2xl font-semibold mb-4">File Information</h2><div class="bg-gray-50 p-6 rounded-lg shadow-inner grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">${createFileInfoTile('Athlete', `${info.firstName} ${info.lastName}`)}${createFileInfoTile('Trial', info.trial)}${createFileInfoTile('Date & Time', `${info.date} @ ${info.time}`)}</div>`; }
            function createFileInfoTile(label, value) { return `<div class="p-4 bg-white rounded-lg shadow"><span class="font-semibold text-gray-500 block text-xs uppercase">${label}</span><span class="text-lg font-bold">${value}</span></div>`; }
            function displayComparisonFileInfo() { const infoA = analysisData.a.fileInfo, infoB = analysisData.b.fileInfo; fileInfoContainer.innerHTML = `<h2 class="text-2xl font-semibold mb-4">File Comparison</h2><div class="grid grid-cols-1 md:grid-cols-2 gap-6">${createComparisonInfoBox(infoA, 'blue')}${createComparisonInfoBox(infoB, 'red')}</div>`; }
            // (UPDATED) Comparison Info Box uses descriptive label
            function createComparisonInfoBox(info, color) { return `<div class="bg-${color}-50 p-4 rounded-lg shadow-inner"><h3 class="font-bold text-lg text-${color}-800 mb-2">${info.descriptiveLabel}</h3><div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm">${createFileInfoTile('Athlete', `${info.firstName} ${info.lastName}`)}${createFileInfoTile('Date', `${info.date} @ ${info.time}`)}</div></div>`; }

            function displaySingleMetrics() { const { metrics, smoothWin } = analysisData.a; metricsContainer.innerHTML = `<h2 class="text-2xl font-semibold mb-4">Key Metrics</h2><div class="bg-gray-50 p-6 rounded-lg shadow-inner grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">${createMetricTile('Total Time', metrics.totalTime.toFixed(2), 's')}${createMetricTile('Total Strokes', metrics.strokeCount, `(${smoothWin}-pt)`)}${createMetricTile('Stroke Rate', metrics.strokeRate.toFixed(1), 'spm')}${createMetricTile('Avg Velocity', metrics.averageVelocity.toFixed(2), 'm/s')}${createMetricTile('Peak Velocity', metrics.peakVelocity.toFixed(2), 'm/s')}${createMetricTile('Stroke Length', metrics.strokeLength.toFixed(2), 'm')}${createMetricTile('Velocity Band', metrics.avgBand !== null ? metrics.avgBand.toFixed(2) : '-', 'm/s', '(Excl. 0-10m)')}${createMetricTile('eWPS', metrics.eWPS.toFixed(2), '')}</div>`; }
            function createMetricTile(label, value, unit, subtext = '') { return `<div class="p-4 bg-white rounded-lg shadow"><span class="font-semibold text-gray-500 block text-sm uppercase">${label}</span><span class="text-3xl font-bold text-blue-600">${value} ${['s', 'm/s', 'spm', 'm'].includes(unit) ? unit : ''}</span><span class="text-xs text-gray-400 block">${!['s', 'm/s', 'spm', 'm'].includes(unit) ? unit : ''} ${subtext}</span></div>`; }
            function displayComparisonMetrics() { const metricsA = analysisData.a.metrics, metricsB = analysisData.b.metrics; metricsContainer.innerHTML = `<h2 class="text-2xl font-semibold mb-4">Key Metrics Comparison</h2><div class="bg-gray-50 p-6 rounded-lg shadow-inner grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">${createComparisonTile('Total Time', metricsA.totalTime, metricsB.totalTime, 's', 2)}${createComparisonTile('Total Strokes', metricsA.strokeCount, metricsB.strokeCount, '', 0)}${createComparisonTile('Stroke Rate', metricsA.strokeRate, metricsB.strokeRate, 'spm', 1)}${createComparisonTile('Avg Velocity', metricsA.averageVelocity, metricsB.averageVelocity, 'm/s', 2)}${createComparisonTile('Peak Velocity', metricsA.peakVelocity, metricsB.peakVelocity, 'm/s', 2)}${createComparisonTile('Stroke Length', metricsA.strokeLength, metricsB.strokeLength, 'm', 2)}${createComparisonTile('Velocity Band', metricsA.avgBand, metricsB.avgBand, 'm/s', 2)}${createComparisonTile('eWPS', metricsA.eWPS, metricsB.eWPS, '', 2)}</div>`; }
            // (UPDATED) createComparisonTile relies on color/stacking, removes A/B prefixes
            function createComparisonTile(label, valueA, valueB, unit, precision) { const diff = valueB - valueA, diffSign = diff > 0 ? '+' : '', diffColor = diff > 0 ? 'text-green-600' : (diff < 0 ? 'text-red-600' : 'text-gray-500'); return `<div class="p-4 bg-white rounded-lg shadow"><span class="font-semibold text-gray-500 block text-sm uppercase">${label}</span><div class="mt-1"><span class="text-2xl font-bold text-blue-600">${valueA !== null ? valueA.toFixed(precision) : '-'} ${unit}</span><span class="text-gray-400 mx-1">|</span><span class="text-2xl font-bold text-red-600">${valueB !== null ? valueB.toFixed(precision) : '-'} ${unit}</span></div><div class="mt-1 text-lg font-semibold ${diffColor}">${diff !== null && !isNaN(diff) ? `${diffSign}${diff.toFixed(precision)} ${unit}` : ''}</div></div>`; }

            function displaySingleSplits() { const pivotedData = pivotSplitData(analysisData.a.splitMetrics); const accordion = document.getElementById('split-accordion'); accordion.innerHTML = createSplitAccordionHTML(pivotedData, 'a'); const firstOpen = accordion.querySelector('div[id^="split-metric-"]:not(.hidden)'); if (firstOpen) firstOpen.querySelectorAll('canvas').forEach(c => { const d = JSON.parse(c.dataset.chartData); drawSplitChart(c.id, d.labels, d.datasets, d.unit, d.isBandChart); }); }
            function displayComparisonSplits() { const pivA = pivotSplitData(analysisData.a.splitMetrics), pivB = pivotSplitData(analysisData.b.splitMetrics); const accordion = document.getElementById('split-accordion'); accordion.innerHTML = createSplitAccordionHTML(pivA, 'a', pivB); const firstOpen = accordion.querySelector('div[id^="split-metric-"]:not(.hidden)'); if (firstOpen) firstOpen.querySelectorAll('canvas').forEach(c => { const d = JSON.parse(c.dataset.chartData); drawSplitChart(c.id, d.labels, d.datasets, d.unit, d.isBandChart); }); }
            
            // (UPDATED) createSplitAccordionHTML passes descriptive labels to chart
            function createSplitAccordionHTML(pivotedDataA, suffixA, pivotedDataB = null) {
                let allSplitHtml = ''; splitChartInstances.forEach(c => c.destroy()); splitChartInstances.clear(); let isOpen = true;
                for (const [metricKey, metricInfoA] of Object.entries(pivotedDataA.metrics)) {
                    if (metricKey === 'avgPeak' || metricKey === 'avgTrough') continue; 
                    const contentId = `split-metric-${metricKey}`; const metricInfoB = pivotedDataB ? pivotedDataB.metrics[metricKey] : null;
                    const isBandChart = metricInfoA.isBandChart || false;
                    
                    let chartDatasets;
                    const labelA = analysisData.a.fileInfo.descriptiveLabel; // Get descriptive label
                    const labelB = pivotedDataB ? analysisData.b.fileInfo.descriptiveLabel : '';

                    if (isBandChart) {
                        const peakA = pivotedDataA.metrics.avgPeak.data; const troughA = pivotedDataA.metrics.avgTrough.data;
                        chartDatasets = [ { label: `Peak (${labelA})`, data: peakA, color: '#3b82f6' }, { label: `Trough (${labelA})`, data: troughA, color: '#a5b4fc', isTrough: true } ]; 
                        if (pivotedDataB) {
                            const peakB = pivotedDataB.metrics.avgPeak.data; const troughB = pivotedDataB.metrics.avgTrough.data;
                             chartDatasets.push({ label: `Peak (${labelB})`, data: peakB, color: '#ef4444' }); 
                             chartDatasets.push({ label: `Trough (${labelB})`, data: troughB, color: '#fca5a5', isTrough: true }); 
                        }
                    } else {
                        chartDatasets = [{ label: labelA, data: metricInfoA.data, color: '#3b82f6' }];
                        if (metricInfoB) chartDatasets.push({ label: labelB, data: metricInfoB.data, color: '#ef4444' });
                    }
                    
                    const chartData = { labels: pivotedDataA.labels, datasets: chartDatasets, unit: metricInfoA.unit, isBandChart };

                    allSplitHtml += `
                        <div class="bg-white rounded-lg shadow-md">
                            <button data-accordion-toggle="true" data-accordion-target="${contentId}" class="w-full flex justify-between items-center p-4 font-semibold text-gray-700 hover:bg-gray-50 transition">
                                <span>${metricInfoA.label}</span>
                                <svg class="w-5 h-5 transition-transform transform ${isOpen ? '' : 'rotate-180'}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path></svg>
                            </button>
                            <div id="${contentId}" class="p-4 bg-gray-50 border-t ${isOpen ? '' : 'hidden'}">
                                <div class="w-full h-64 mb-4"><canvas id="chart-metric-${metricKey}" data-chart-data='${JSON.stringify(chartData)}'></canvas></div>
                                <div class="split-data-list">${pivotedDataA.labels.map((label, i) => createSplitTileHTML(label, metricInfoA, i, metricInfoB)).join('')}</div>
                            </div>
                        </div>`; isOpen = false;
                } return allSplitHtml;
            }

            // (UPDATED) createSplitTileHTML uses avgPeak/avgTrough for band display, removes A/B labels
            function createSplitTileHTML(label, metricInfoA, index, metricInfoB = null) {
                const isFirstBandSegment = metricInfoA.isBandChart && index === 0;

                const formatValue = (value, unit, isFirstBand) => {
                    if (isFirstBand) return '-';
                    if (value === null || isNaN(value)) return 'N/A';
                    if (unit === 'strokes') return value;
                    if (unit === 'spm') return value.toFixed(1);
                    return value.toFixed(2);
                };
                
                let valueAHtml, valueBHtml = '';
                
                if (metricInfoA.isBandChart) {
                    const peakA = analysisData.a.splitMetrics[index]?.metrics.avgPeak;
                    const troughA = analysisData.a.splitMetrics[index]?.metrics.avgTrough;
                    valueAHtml = `<div class="flex justify-center items-center"><span class="text-lg font-bold text-blue-600">${isFirstBandSegment ? '-' : `${peakA?.toFixed(2)} - ${troughA?.toFixed(2)} ${metricInfoA.unit || ''}`}</span></div>`;
                    if (metricInfoB) {
                        const peakB = analysisData.b.splitMetrics[index]?.metrics.avgPeak;
                        const troughB = analysisData.b.splitMetrics[index]?.metrics.avgTrough;
                        valueBHtml = `<div class="flex justify-center items-center mt-1 pt-1 border-t"><span class="text-lg font-bold text-red-600">${isFirstBandSegment ? '-' : `${peakB?.toFixed(2)} - ${troughB?.toFixed(2)} ${metricInfoB.unit || ''}`}</span></div>`;
                    }
                } else {
                     const valA = formatValue(metricInfoA.data[index], metricInfoA.unit, false);
                     const unitDisplayA = metricInfoA.unit || '';
                     valueAHtml = `<div class="flex justify-center items-center"><span class="text-lg font-bold text-blue-600">${valA} ${unitDisplayA}</span></div>`;
                    if (metricInfoB) {
                        const valB = formatValue(metricInfoB.data[index], metricInfoB.unit, false);
                        const unitDisplayB = metricInfoB.unit || '';
                        valueBHtml = `<div class="flex justify-center items-center mt-1 pt-1 border-t"><span class="text-lg font-bold text-red-600">${valB} ${unitDisplayB}</span></div>`;
                    }
                }

                return `<div class="flex-shrink-0 w-40 mr-2 p-3 bg-white rounded-lg shadow-inner"><span class="font-semibold text-gray-500 block text-xs uppercase text-center mb-2">${label}</span>${valueAHtml}${valueBHtml}</div>`;
            }
        });
    </script>
</body>
</html>

