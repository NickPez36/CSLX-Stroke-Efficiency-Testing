<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing Data Loader</title>
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <!-- 3. Chart.js Zoom Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for split data */
        .split-data-list {
            display: flex;
            overflow-x: auto;
            padding-bottom: 1rem;
            white-space: nowrap;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: thin; /* Firefox */
        }
        .split-data-list::-webkit-scrollbar {
            height: 8px;
        }
        .split-data-list::-webkit-scrollbar-track {
            background: #f1f5f9; /* gray-100 */
            border-radius: 10px;
        }
        .split-data-list::-webkit-scrollbar-thumb {
            background: #94a3b8; /* gray-400 */
            border-radius: 10px;
        }
        .split-data-list::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* gray-500 */
        }
        /* Simple spinner */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Styling for active toggle button */
        .toggle-btn-active {
            background-color: #3b82f6; /* blue-600 */
            color: white;
        }
        .toggle-btn-inactive {
            background-color: #e5e7eb; /* gray-200 */
            color: #4b5563; /* gray-600 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 antialiased">

    <!-- Main Container -->
    <div class="max-w-7xl mx-auto p-4 md:p-8">
        
        <header class="mb-8">
            <h1 class="text-4xl font-bold text-gray-800">Canoe Slalom Performance Dashboard</h1>
        </header>

        <main>
            <!-- 1. Data Selection -->
            <div class="bg-gray-50 p-6 rounded-lg shadow-inner mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold text-gray-800">Data Selection</h2>
                    <!-- (NEW) Compare Button -->
                    <button id="add-comparison-btn" class="text-sm text-blue-600 hover:text-blue-800 font-medium">
                        + Add Comparison
                    </button>
                    <button id="remove-comparison-btn" class="hidden text-sm text-red-600 hover:text-red-800 font-medium">
                        - Remove Comparison
                    </button>
                </div>
                
                <div id="loader-area" class="flex items-center space-x-2 text-gray-600 hidden">
                    <div class="spinner"></div>
                    <span id="loader-text">Loading...</span>
                </div>
                
                <!-- File A Selection -->
                <div id="selection-ui-a" class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <!-- Athlete Dropdown -->
                    <div>
                        <label for="athlete-select-a" class="block text-sm font-medium text-gray-700">1. Select Athlete (File A)</label>
                        <select id="athlete-select-a" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <!-- Date Dropdown -->
                    <div>
                        <label for="date-select-a" class="block text-sm font-medium text-gray-700">2. Select Date (File A)</label>
                        <select id="date-select-a" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Select athlete first</option>
                        </select>
                    </div>
                    <!-- File Dropdown -->
                    <div>
                        <label for="file-select-a" class="block text-sm font-medium text-gray-700">3. Select Trial (File A)</label>
                        <select id="file-select-a" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Select date first</option>
                        </select>
                    </div>
                    <!-- Load Button -->
                    <div class="self-end">
                        <button id="load-data-btn" class="mt-1 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition disabled:bg-gray-300" disabled>
                            Load Data
                        </button>
                    </div>
                </div>

                <!-- (NEW) File B Selection (hidden by default) -->
                <div id="selection-ui-b" class="hidden grid grid-cols-1 md:grid-cols-4 gap-4 mt-4 pt-4 border-t border-gray-300">
                    <!-- Athlete Dropdown -->
                    <div>
                        <label for="athlete-select-b" class="block text-sm font-medium text-gray-700">1. Select Athlete (File B)</label>
                        <select id="athlete-select-b" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <!-- Date Dropdown -->
                    <div>
                        <label for="date-select-b" class="block text-sm font-medium text-gray-700">2. Select Date (File B)</label>
                        <select id="date-select-b" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Select athlete first</option>
                        </select>
                    </div>
                    <!-- File Dropdown -->
                    <div>
                        <label for="file-select-b" class="block text-sm font-medium text-gray-700">3. Select Trial (File B)</label>
                        <select id="file-select-b" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" disabled>
                            <option value="">Select date first</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- 2. Message/Error Area -->
            <div id="message-area" class="hidden mt-6 p-4 rounded-lg">
                <!-- Content will be injected by JS -->
            </div>

            <!-- 3. File Info Display -->
            <div id="file-info-container" class="hidden mt-8">
                <!-- Content will be injected by JS -->
            </div>

            <!-- 4. Key Metrics -->
            <div id="metrics-container" class="hidden mt-8">
                <!-- Content will be injected by JS -->
            </div>

            <!-- 5. Velocity Chart -->
            <div id="chart-container" class="hidden mt-8">
                <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-4">
                    <h2 class="text-2xl font-semibold text-gray-800">Performance Chart</h2>
                    <!-- (NEW) Chart Toggles -->
                    <div id="chart-toggles" class="hidden mt-2 sm:mt-0 space-x-2">
                        <button id="chart-toggle-velocity" class="toggle-btn-active px-4 py-2 text-sm font-medium rounded-lg">Velocity</button>
                        <button id="chart-toggle-acceleration" class="toggle-btn-inactive px-4 py-2 text-sm font-medium rounded-lg">Acceleration</button>
                    </div>
                    <button id="reset-zoom-btn" class="mt-2 sm:mt-0 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition text-sm">
                        Reset Zoom
                    </button>
                </div>
                <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
                    <canvas id="velocity-chart"></canvas>
                </div>
            </div>

            <!-- 6. Split Analysis -->
            <div id="split-analysis-container" class="hidden mt-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Split Analysis (100m)</h2>
                <div id="split-accordion" class="space-y-2">
                    <!-- Collapsible split data will be injected by JS -->
                </div>
            </div>

        </main>
    </div>

    <!-- JavaScript -->
    <script>
        // Global chart instances
        let velocityChartInstance = null;
        let splitChartInstances = new Map();

        // (NEW) Global state for analysis data
        let analysisData = {
            a: null, // To store file A's analysis
            b: null  // To store file B's analysis
        };
        let activeChartMetric = 'velocity'; // 'velocity' or 'acceleration'

        // GitHub API Constants
        const GH_USER = 'NickPez36';
        const GH_REPO = 'CSLX-Stroke-Efficiency-Testing';
        const API_BASE_URL = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/contents/`;
        const DATA_PATH = 'data';

        document.addEventListener('DOMContentLoaded', () => {
            // Get all DOM elements
            const messageArea = document.getElementById('message-area');
            const fileInfoContainer = document.getElementById('file-info-container');
            const metricsContainer = document.getElementById('metrics-container');
            const chartContainer = document.getElementById('chart-container');
            const resetZoomBtn = document.getElementById('reset-zoom-btn');
            const splitAnalysisContainer = document.getElementById('split-analysis-container');
            const loaderArea = document.getElementById('loader-area');
            const loaderText = document.getElementById('loader-text');
            const loadDataBtn = document.getElementById('load-data-btn');

            // (NEW) Comparison UI Elements
            const addComparisonBtn = document.getElementById('add-comparison-btn');
            const removeComparisonBtn = document.getElementById('remove-comparison-btn');
            const selectionUiB = document.getElementById('selection-ui-b');
            const chartToggles = document.getElementById('chart-toggles');
            const chartToggleVelocity = document.getElementById('chart-toggle-velocity');
            const chartToggleAcceleration = document.getElementById('chart-toggle-acceleration');

            // (NEW) Dropdown elements by file suffix ('a' or 'b')
            const getSelectElements = (suffix) => ({
                athlete: document.getElementById(`athlete-select-${suffix}`),
                date: document.getElementById(`date-select-${suffix}`),
                file: document.getElementById(`file-select-${suffix}`)
            });

            // --- UI Event Listeners ---

            addComparisonBtn.addEventListener('click', () => {
                selectionUiB.classList.remove('hidden');
                addComparisonBtn.classList.add('hidden');
                removeComparisonBtn.classList.remove('hidden');
                loadDataBtn.textContent = "Load Comparison";
                loadAthletes('b'); // Load athletes for the new dropdowns
            });

            removeComparisonBtn.addEventListener('click', () => {
                selectionUiB.classList.add('hidden');
                addComparisonBtn.classList.remove('hidden');
                removeComparisonBtn.classList.add('hidden');
                loadDataBtn.textContent = "Load Data";
                analysisData.b = null; // Clear file B data
                // If File A exists, re-render in single mode
                if (analysisData.a) {
                    displayUI();
                }
            });

            chartToggleVelocity.addEventListener('click', () => {
                activeChartMetric = 'velocity';
                chartToggleVelocity.classList.replace('toggle-btn-inactive', 'toggle-btn-active');
                chartToggleAcceleration.classList.replace('toggle-btn-active', 'toggle-btn-inactive');
                drawMetricsChart(); // Redraw chart with new metric
            });

            chartToggleAcceleration.addEventListener('click', () => {
                activeChartMetric = 'acceleration';
                chartToggleAcceleration.classList.replace('toggle-btn-inactive', 'toggle-btn-active');
                chartToggleVelocity.classList.replace('toggle-btn-active', 'toggle-btn-inactive');
                drawMetricsChart(); // Redraw chart with new metric
            });

            // --- GitHub API Functions ---

            function showLoader(text) {
                loaderText.textContent = text;
                loaderArea.classList.remove('hidden');
            }

            function hideLoader() {
                loaderArea.classList.add('hidden');
            }

            async function handleApiError(response, error) {
                let errorMsg = 'Failed to load data from GitHub. Please check console.';
                if (error) {
                    console.error('GitHub API Error:', error);
                    errorMsg += ` ${error.message}.`;
                } else if (response) {
                    console.error(`GitHub API Error: ${response.status} ${response.statusText}`);
                    errorMsg += ` Status: ${response.status} ${response.statusText}.`;
                    if (response.status === 404) errorMsg += ' The requested file or folder was not found.';
                    else if (response.status === 403) errorMsg += ' API rate limit exceeded. Please wait a moment and try again.';
                }
                showMessage('error', errorMsg);
                hideLoader();
            }

            // (UPDATED) To handle 'a' and 'b' dropdowns
            async function loadAthletes(suffix = 'a') {
                showLoader('Loading athletes...');
                const selects = getSelectElements(suffix);
                try {
                    const response = await fetch(API_BASE_URL + DATA_PATH);
                    if (!response.ok) { await handleApiError(response); return; }
                    const data = await response.json();
                    
                    const athleteFolders = data.filter(item => item.type === 'dir');
                    selects.athlete.innerHTML = '<option value="">Select athlete</option>';
                    athleteFolders.forEach(folder => {
                        const option = new Option(folder.name, folder.name);
                        selects.athlete.add(option);
                    });
                    selects.athlete.disabled = false;
                } catch (error) {
                    await handleApiError(null, error);
                } finally {
                    hideLoader();
                }
            }

            // (UPDATED)
            async function loadDates(athleteName, suffix = 'a') {
                const selects = getSelectElements(suffix);
                if (!athleteName) return;
                showLoader(`Loading dates for ${athleteName}...`);
                
                selects.date.innerHTML = '<option value="">Select date</option>';
                selects.date.disabled = true;
                selects.file.innerHTML = '<option value="">Select date first</option>';
                selects.file.disabled = true;
                if (suffix === 'a') loadDataBtn.disabled = true;

                try {
                    const path = `${DATA_PATH}/${encodeURIComponent(athleteName)}`;
                    const response = await fetch(API_BASE_URL + path);
                    if (!response.ok) { await handleApiError(response); return; }
                    const data = await response.json();

                    const dateFolders = data.filter(item => item.type === 'dir' && /^\d{8}$/.test(item.name));
                    dateFolders.forEach(folder => {
                        const option = new Option(folder.name, folder.name);
                        selects.date.add(option);
                    });
                    selects.date.disabled = false;
                } catch (error) {
                    await handleApiError(null, error);
                } finally {
                    hideLoader();
                }
            }

            // (UPDATED)
            async function loadFiles(athleteName, dateFolder, suffix = 'a') {
                const selects = getSelectElements(suffix);
                if (!dateFolder) return;
                showLoader(`Loading files for ${dateFolder}...`);

                selects.file.innerHTML = '<option value="">Select trial</option>';
                selects.file.disabled = true;
                if (suffix === 'a') loadDataBtn.disabled = true;

                try {
                    const path = `${DATA_PATH}/${encodeURIComponent(athleteName)}/${encodeURIComponent(dateFolder)}`;
                    const response = await fetch(API_BASE_URL + path);
                    if (!response.ok) { await handleApiError(response); return; }
                    const data = await response.json();

                    const files = data.filter(item => item.type === 'file' && item.name.endsWith('.csv'));
                    files.forEach(file => {
                        const option = new Option(file.name, file.name);
                        option.dataset.url = file.download_url;
                        selects.file.add(option);
                    });
                    selects.file.disabled = false;
                } catch (error) {
                    await handleApiError(null, error);
                } finally {
                    hideLoader();
                }
            }
            
            // (NEW) Helper to fetch and parse a single file
            async function loadAndAnalyzeFile(suffix) {
                const selects = getSelectElements(suffix);
                const selectedOption = selects.file.selectedOptions[0];
                if (!selectedOption || !selectedOption.dataset.url) {
                    return null; // No file selected
                }

                const fileName = selectedOption.value;
                const downloadUrl = selectedOption.dataset.url;
                
                showLoader(`Loading ${fileName}...`);

                try {
                    const response = await fetch(downloadUrl);
                    if (!response.ok) { await handleApiError(response); return null; }
                    const csvString = await response.text();
                    
                    // Run analysis, but don't display yet
                    const fileInfo = parseFileInfo(fileName, suffix);
                    const csvData = parseCSV(csvString);
                    const chartData = prepareChartData(csvData.headers, csvData.data);
                    const metricsResult = calculateAllMetrics(chartData.velocityData, chartData.timeData, fileInfo.trial);

                    return { fileInfo, chartData, ...metricsResult }; // Return all data
                } catch (error) {
                    showMessage('error', `Failed to analyze ${fileName}: ${error.message}`);
                    console.error(error);
                    return null;
                }
            }

            // (NEW) Main Load Button Handler
            async function handleLoadData() {
                loadDataBtn.disabled = true;
                showMessage('info', 'Loading data...');
                
                // Always load File A
                analysisData.a = await loadAndAnalyzeFile('a');
                
                // Load File B only if it's visible and selected
                analysisData.b = null;
                if (!selectionUiB.classList.contains('hidden')) {
                    analysisData.b = await loadAndAnalyzeFile('b');
                }
                
                if (analysisData.a) { // At least File A must load successfully
                    showMessage('success', 'Data loaded. Displaying results...');
                    displayUI(); // Master display function
                } else {
                    showMessage('error', 'Failed to load File A. Please check selection and try again.');
                }

                hideLoader();
                loadDataBtn.disabled = false;
            }

            // --- Dropdown Event Listeners (Updated) ---
            getSelectElements('a').athlete.addEventListener('change', (e) => loadDates(e.target.value, 'a'));
            getSelectElements('a').date.addEventListener('change', (e) => loadFiles(getSelectElements('a').athlete.value, e.target.value, 'a'));
            getSelectElements('a').file.addEventListener('change', () => {
                loadDataBtn.disabled = !getSelectElements('a').file.value;
            });
            
            getSelectElements('b').athlete.addEventListener('change', (e) => loadDates(e.target.value, 'b'));
            getSelectElements('b').date.addEventListener('change', (e) => loadFiles(getSelectElements('b').athlete.value, e.target.value, 'b'));
            
            loadDataBtn.addEventListener('click', handleLoadData);


            // --- (NEW) Master Display Function ---
            function displayUI() {
                // Clear all dynamic content
                fileInfoContainer.innerHTML = '';
                metricsContainer.innerHTML = '';
                
                // (FIXED) Only clear the accordion content, not the container
                const accordion = splitAnalysisContainer.querySelector('#split-accordion');
                if (accordion) {
                    accordion.innerHTML = '';
                }

                if (analysisData.b) {
                    // --- COMPARISON MODE ---
                    chartToggles.classList.remove('hidden');
                    resetZoomBtn.classList.remove('hidden');
                    displayComparisonFileInfo();
                    displayComparisonMetrics();
                    displayComparisonSplits();
                } else if (analysisData.a) {
                    // --- SINGLE FILE MODE ---
                    chartToggles.classList.add('hidden');
                    resetZoomBtn.classList.remove('hidden');
                    displaySingleFileInfo();
                    displaySingleMetrics();
                    displaySingleSplits();
                } else {
                    // --- NO DATA ---
                    fileInfoContainer.classList.add('hidden');
                    metricsContainer.classList.add('hidden');
                    chartContainer.classList.add('hidden');
                    splitAnalysisContainer.classList.add('hidden');
                    return;
                }

                // Show containers (but not chart, chart is drawn after)
                fileInfoContainer.classList.remove('hidden');
                metricsContainer.classList.remove('hidden');
                splitAnalysisContainer.classList.remove('hidden');
                
                // Draw main chart
                drawMetricsChart();
                chartContainer.classList.remove('hidden');
            }
            

            // --- Zoom Reset Handler ---
            resetZoomBtn.addEventListener('click', () => {
                if (velocityChartInstance) {
                    velocityChartInstance.resetZoom();
                }
            });

            // --- Accordion Event Handler (for Split Analysis) ---
            document.addEventListener('click', (e) => {
                const target = e.target.closest('[data-accordion-toggle]');
                if (target) {
                    const contentId = target.getAttribute('data-accordion-target');
                    const content = document.getElementById(contentId);
                    const icon = target.querySelector('svg');
                    
                    if (content) {
                        content.classList.toggle('hidden');
                        icon.classList.toggle('rotate-180');
                        
                        // Render charts on first open
                        content.querySelectorAll('canvas').forEach(canvas => {
                            const canvasId = canvas.id;
                            if (canvasId && !splitChartInstances.has(canvasId)) {
                                const chartData = JSON.parse(canvas.dataset.chartData);
                                // (UPDATED) Pass array of datasets
                                drawSplitChart(canvasId, chartData.labels, chartData.datasets, chartData.unit);
                            }
                        });
                    }
                }
            });

            // --- Start application by loading athletes ---
            loadAthletes('a');


            // --- Parsing Functions ---

            function parseFileInfo(filename, suffix = 'a') {
                const regex = /^(\d{8})_(\d{6})_([^_]+)_([^_]+)_(\w+)$/;
                const match = filename.replace('.csv', '').match(regex);
                
                const selects = getSelectElements(suffix);

                if (!match) {
                    console.warn(`Filename ${filename} does not match format. Parsing from folder.`);
                    const athlete = selects.athlete.value;
                    const date = selects.date.value;
                    const trial = filename.replace('.csv', '');
                    
                    if(athlete && date) {
                        const dateStr = `${date.substring(0, 4)}-${date.substring(4, 6)}-${date.substring(6, 8)}`;
                        const nameParts = athlete.split(' ');
                        const firstName = nameParts[0] || '';
                        const lastName = nameParts.slice(1).join(' ') || '';

                        return { date: dateStr, time: "N/A", lastName, firstName, trial };
                    }
                    throw new Error("Filename format error and athlete/date info missing.");
                }
                
                const [_, date, time, lastName, firstName, trial] = match;
                const formattedDate = `${date.substring(0, 4)}-${date.substring(4, 6)}-${date.substring(6, 8)}`;
                const formattedTime = `${time.substring(0, 2)}:${time.substring(2, 4)}:${time.substring(4, 6)}`;

                return { date: formattedDate, time: formattedTime, lastName, firstName, trial };
            }

            function parseCSV(csvString, headerRow = 29) {
                const rows = csvString.split(/\r?\n/);
                if (rows.length < headerRow + 1) throw new Error(`File < ${headerRow + 1} rows.`);
                const headers = rows[headerRow - 1].split(',').map(h => h.trim());
                
                const data = [];
                for (let i = headerRow; i < rows.length; i++) {
                    const row = rows[i].split(',').map(d => d.trim());
                    // (FIXED) Check if row has AT LEAST as many columns as header, not exactly equal
                    if (row.length >= headers.length && row[0] !== '') data.push(row);
                }
                if (data.length === 0) throw new Error("No data rows found. Check if headers are on row 29.");
                return { headers, data };
            }

            // --- Helper Functions ---
            function simpleMovingAverage(data, windowSize) {
                const smoothed = new Array(data.length).fill(null);
                if (windowSize <= 0) return data;
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i];
                    if (i >= windowSize) {
                        sum -= data[i - windowSize];
                        smoothed[i] = sum / windowSize;
                    } else if (i === windowSize - 1) {
                        smoothed[i] = sum / windowSize;
                    }
                }
                return smoothed;
            }

            function cumulativeMovingAverage(data) {
                const cma = new Array(data.length);
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i];
                    cma[i] = sum / (i + 1);
                }
                return cma;
            }

            // --- Charting Functions ---

            function prepareChartData(headers, data) {
                const distanceInterval = 0.02;
                const secondsIndex = headers.findIndex(h => h.toLowerCase() === 'seconds');
                if (secondsIndex === -1) throw new Error("'Seconds' column not found.");

                const chartLabels = [], velocities = [], rawAccelerations = [], times = [];

                data.forEach((row, index) => {
                    const time = parseFloat(row[secondsIndex]);
                    if (!isNaN(time) && time > 0) {
                        const distance = (index + 1) * distanceInterval;
                        const velocity = distanceInterval / time;
                        chartLabels.push(distance.toFixed(2));
                        velocities.push(velocity);
                        times.push(time);
                        if (index > 0 && velocities[index - 1] !== null) {
                            rawAccelerations.push((velocity - velocities[index - 1]) / time);
                        } else {
                            rawAccelerations.push(0);
                        }
                    } else {
                        chartLabels.push(null); velocities.push(null); times.push(null); rawAccelerations.push(null);
                    }
                });
                
                const validIndices = velocities.map((v, i) => v !== null ? i : -1).filter(i => i !== -1);
                const finalLabels = validIndices.map(i => chartLabels[i]);
                const finalVelocities = validIndices.map(i => velocities[i]);
                const finalRawAccelerations = validIndices.map(i => rawAccelerations[i]);
                const finalTimes = validIndices.map(i => times[i]);

                if (finalVelocities.length === 0) throw new Error("No valid data to plot.");

                return {
                    labels: finalLabels,
                    velocityData: finalVelocities,
                    accelerationData: cumulativeMovingAverage(finalRawAccelerations),
                    timeData: finalTimes
                };
            }

            // (UPDATED) Draws chart based on global state
            function drawMetricsChart() {
                const ctx = document.getElementById('velocity-chart').getContext('2d');
                if (velocityChartInstance) velocityChartInstance.destroy();
                
                let datasets = [];
                const dataA = analysisData.a;
                const dataB = analysisData.b;

                if (dataB) {
                    // --- COMPARISON MODE ---
                    if (activeChartMetric === 'velocity') {
                        datasets = [
                            { label: `File A (${dataA.fileInfo.trial})`, data: dataA.smoothedVelocities.map(v => v ? v.toFixed(2) : null), borderColor: '#3b82f6', yAxisID: 'y-velocity', tension: 0.1, pointRadius: 1, fill: false },
                            { label: `File B (${dataB.fileInfo.trial})`, data: dataB.smoothedVelocities.map(v => v ? v.toFixed(2) : null), borderColor: '#ef4444', yAxisID: 'y-velocity', tension: 0.1, pointRadius: 1, fill: false }
                        ];
                    } else { // Acceleration
                        datasets = [
                            { label: `File A (${dataA.fileInfo.trial})`, data: dataA.chartData.accelerationData.map(a => a ? a.toFixed(2) : null), borderColor: '#3b82f6', yAxisID: 'y-acceleration', tension: 0.4, pointRadius: 1, fill: false },
                            { label: `File B (${dataB.fileInfo.trial})`, data: dataB.chartData.accelerationData.map(a => a ? a.toFixed(2) : null), borderColor: '#ef4444', yAxisID: 'y-acceleration', tension: 0.4, pointRadius: 1, fill: false }
                        ];
                    }
                } else if (dataA) {
                    // --- SINGLE FILE MODE ---
                    datasets = [
                        { label: 'Smoothed Velocity (m/s)', data: dataA.smoothedVelocities.map(v => v ? v.toFixed(2) : null), borderColor: '#3b82f6', yAxisID: 'y-velocity', tension: 0.1, pointRadius: 1, fill: false },
                        { label: `Acceleration (m/s²)`, data: dataA.chartData.accelerationData.map(a => a ? a.toFixed(2) : null), borderColor: '#ec4899', yAxisID: 'y-acceleration', tension: 0.4, pointRadius: 1, fill: false }
                    ];
                }

                velocityChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: { labels: dataA.chartData.labels, datasets: datasets },
                    options: {
                        responsive: true, maintainAspectRatio: true, interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: { title: { display: true, text: 'Distance (m)', font: { size: 14 } } },
                            'y-velocity': { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Velocity (m/s)', font: { size: 14 }, color: '#3b82f6' }, beginAtZero: true },
                            'y-acceleration': { type: 'linear', display: true, position: 'right', title: { display: true, text: 'Acceleration (m/s²)', font: { size: 14 }, color: '#ec4899' }, grid: { drawOnChartArea: false } }
                        },
                        plugins: {
                            tooltip: { mode: 'index', intersect: false, callbacks: { title: (items) => `Distance: ${items[0].label} m` } },
                            zoom: { pan: { enabled: true, mode: 'x' }, zoom: { wheel: { enabled: false }, pinch: { enabled: false }, drag: { enabled: true, mode: 'x' } } }
                        }
                    }
                });
            }

            // (UPDATED) Can now handle one or more datasets
            function drawSplitChart(canvasId, labels, datasets, dataUnit) {
                const ctx = document.getElementById(canvasId);
                if (!ctx) return;
                
                let yMin = 0, yMax = 1;
                // (UPDATED) Check all datasets for min/max
                const allData = datasets.flatMap(ds => ds.data).filter(v => v !== null && isFinite(v));

                if (allData.length > 0) {
                    const dataMin = Math.min(...allData);
                    const dataMax = Math.max(...allData);
                    const padding = (dataMax - dataMin) * 0.1;
                    const finalPadding = padding === 0 ? (dataMax === 0 ? 1 : dataMax * 0.1) : padding; 
                    yMin = dataMin - finalPadding;
                    yMax = dataMax + finalPadding;
                    if (dataMin >= 0 && yMin < 0) yMin = 0;
                }
                
                // (UPDATED) Create datasets for chart
                const chartDatasets = datasets.map(ds => ({
                    label: ds.label,
                    data: ds.data,
                    fill: false,
                    borderColor: ds.color || '#3b82f6',
                    borderWidth: 2,
                    tension: 0.1,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    pointBackgroundColor: ds.color || '#3b82f6'
                }));

                const chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets: chartDatasets }, // (UPDATED)
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: { y: { min: yMin, max: yMax, title: { display: true, text: dataUnit, font: { size: 10 } } }, x: { ticks: { font: { size: 10 } } } },
                        plugins: { 
                            legend: { display: datasets.length > 1 }, // (UPDATED) Show legend only for comparison
                            tooltip: { callbacks: { title: (items) => `Split: ${items[0].label}` } } 
                        }
                    }
                });
                splitChartInstances.set(canvasId, chart);
            }

            // --- Metrics Calculation ---

            function calculateSegmentMetrics(velocities, times, smoothingWindow) {
                if (!velocities || velocities.length === 0 || !times || times.length === 0 || velocities.length !== times.length) {
                    return { strokeCount: 0, peakVelocity: 0, averageVelocity: 0, totalTime: 0, strokeRate: 0, eWPS: 0, strokeLength: 0 };
                }

                const smoothedVelocities = simpleMovingAverage(velocities, smoothingWindow).filter(v => v !== null);
                let strokeCount = 0;
                if (smoothedVelocities.length > 0) {
                    const smoothedSum = smoothedVelocities.reduce((acc, v) => acc + v, 0);
                    const avgSmoothedVel = smoothedSum / smoothedVelocities.length;
                    let wasBelowAverage = true;
                    for (const currentVel of smoothedVelocities) {
                        if (currentVel > avgSmoothedVel && wasBelowAverage) { strokeCount++; wasBelowAverage = false; }
                        else if (currentVel < avgSmoothedVel) wasBelowAverage = true; 
                    }
                }

                let peakVelocity = 0, velocitySum = 0;
                for (const v of velocities) { if (v > peakVelocity) peakVelocity = v; velocitySum += v; }
                
                const totalTime = times.reduce((acc, t) => acc + t, 0);
                const averageVelocity = (velocities.length > 0) ? (velocitySum / velocities.length) : 0;
                
                let strokeRate = 0, eWPS = 0, strokeLength = 0;
                if (totalTime > 0 && strokeCount > 0) {
                    strokeRate = (strokeCount / totalTime) * 60;
                    eWPS = (averageVelocity ** 3) / (strokeRate / 60);
                }
                const distance = velocities.length * 0.02;
                if (strokeCount > 0) strokeLength = distance / strokeCount;
                
                return { strokeCount, peakVelocity, averageVelocity, totalTime, strokeRate, eWPS, strokeLength };
            }

            function calculateAllMetrics(velocities, times, trialName) {
                const distancePerPoint = 0.02;
                const smoothingWindow = (trialName.toUpperCase() === "MAX") ? 10 : 20;
                const totalMetrics = calculateSegmentMetrics(velocities, times, smoothingWindow);
                const splitMetrics = [];
                const splitEndMeters = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
                let startRow = 0, startMeter = 0;

                for (const endMeter of splitEndMeters) {
                    const endRow = Math.round(endMeter / distancePerPoint);
                    const segmentVelocities = velocities.slice(startRow, endRow);
                    const segmentTimes = times.slice(startRow, endRow);
                    const segmentMetrics = calculateSegmentMetrics(segmentVelocities, segmentTimes, smoothingWindow);
                    splitMetrics.push({ label: `${startMeter}m - ${endMeter}m`, metrics: segmentMetrics });
                    startRow = endRow; startMeter = endMeter;
                    if (startRow >= velocities.length) break;
                }
                return { metrics: totalMetrics, splitMetrics, smoothedVelocities: simpleMovingAverage(velocities, smoothingWindow), smoothingWindow };
            }
            
            function pivotSplitData(splitMetrics) {
                const labels = splitMetrics.map(s => s.label);
                const metricData = {
                    totalTime: { label: "Split Time", unit: "s", data: [] },
                    averageVelocity: { label: "Average Velocity", unit: "m/s", data: [] },
                    peakVelocity: { label: "Peak Velocity", unit: "m/s", data: [] },
                    strokeCount: { label: "Strokes", unit: "strokes", data: [] },
                    strokeRate: { label: "Stroke Rate", unit: "spm", data: [] },
                    strokeLength: { label: "Stroke Length", unit: "m", data: [] },
                    eWPS: { label: "eWPS", unit: "", data: [] }
                };
                for (const split of splitMetrics) {
                    for (const key in metricData) {
                        metricData[key].data.push(split.metrics[key]);
                    }
                }
                return { labels, metrics: metricData };
            }

            // --- Display Functions ---

            function showMessage(type, text) {
                messageArea.innerHTML = text;
                messageArea.classList.remove('hidden', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'bg-blue-100', 'text-blue-700');
                const typeClasses = {
                    error: ['bg-red-100', 'text-red-700'],
                    success: ['bg-green-100', 'text-green-700'],
                    info: ['bg-blue-100', 'text-blue-700']
                };
                messageArea.classList.add(...(typeClasses[type] || typeClasses.info));
            }

            // (NEW) Single File Info
            function displaySingleFileInfo() {
                const info = analysisData.a.fileInfo;
                fileInfoContainer.innerHTML = `
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">File Information</h2>
                    <div class="bg-gray-50 p-6 rounded-lg shadow-inner grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                        <div class="p-4 bg-white rounded-lg shadow">
                            <span class="font-semibold text-gray-500 block text-xs uppercase">Athlete</span>
                            <span class="text-lg font-bold">${info.firstName} ${info.lastName}</span>
                        </div>
                        <div class="p-4 bg-white rounded-lg shadow">
                            <span class="font-semibold text-gray-500 block text-xs uppercase">Trial</span>
                            <span class="text-lg font-bold">${info.trial}</span>
                        </div>
                        <div class="p-4 bg-white rounded-lg shadow">
                            <span class="font-semibold text-gray-500 block text-xs uppercase">Date & Time</span>
                            <span class="text-lg font-bold">${info.date} @ ${info.time}</span>
                        </div>
                    </div>`;
            }

            // (NEW) Comparison File Info
            function displayComparisonFileInfo() {
                const infoA = analysisData.a.fileInfo;
                const infoB = analysisData.b.fileInfo;
                fileInfoContainer.innerHTML = `
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">File Comparison</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- File A Info -->
                        <div class="bg-blue-50 p-4 rounded-lg shadow-inner">
                            <h3 class="font-bold text-lg text-blue-800 mb-2">File A: ${infoA.trial}</h3>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm">
                                <div class="p-3 bg-white rounded-lg shadow">
                                    <span class="font-semibold text-gray-500 block text-xs uppercase">Athlete</span>
                                    <span class="text-md font-bold">${infoA.firstName} ${infoA.lastName}</span>
                                </div>
                                <div class="p-3 bg-white rounded-lg shadow">
                                    <span class="font-semibold text-gray-500 block text-xs uppercase">Date</span>
                                    <span class="text-md font-bold">${infoA.date} @ ${infoA.time}</span>
                                </div>
                            </div>
                        </div>
                        <!-- File B Info -->
                        <div class="bg-red-50 p-4 rounded-lg shadow-inner">
                            <h3 class="font-bold text-lg text-red-800 mb-2">File B: ${infoB.trial}</h3>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm">
                                <div class="p-3 bg-white rounded-lg shadow">
                                    <span class="font-semibold text-gray-500 block text-xs uppercase">Athlete</span>
                                    <span class="text-md font-bold">${infoB.firstName} ${infoB.lastName}</span>
                                </div>
                                <div class="p-3 bg-white rounded-lg shadow">
                                    <span class="font-semibold text-gray-500 block text-xs uppercase">Date</span>
                                    <span class="text-md font-bold">${infoB.date} @ ${infoB.time}</span>
                                </div>
                            </div>
                        </div>
                    </div>`;
            }

            // (NEW) Single Metrics Display
            function displaySingleMetrics() {
                const { metrics, smoothingWindow } = analysisData.a;
                metricsContainer.innerHTML = `
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Key Metrics (100m Total)</h2>
                    <div class="bg-gray-50 p-6 rounded-lg shadow-inner grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        ${createMetricTile('Total Time', metrics.totalTime.toFixed(2), 's')}
                        ${createMetricTile('Total Strokes', metrics.strokeCount, `(${smoothingWindow}-pt Avg Cross)`)}
                        ${createMetricTile('Stroke Rate', metrics.strokeRate.toFixed(1), 'spm')}
                        ${createMetricTile('Average Velocity', metrics.averageVelocity.toFixed(2), 'm/s')}
                        ${createMetricTile('Peak Velocity', metrics.peakVelocity.toFixed(2), 'm/s')}
                        ${createMetricTile('Stroke Length', metrics.strokeLength.toFixed(2), 'm')}
                        ${createMetricTile('eWPS', metrics.eWPS.toFixed(2), 'AvgVel³ / (SR/60)')}
                    </div>`;
            }

            // (NEW) Comparison Metrics Display
            function displayComparisonMetrics() {
                const metricsA = analysisData.a.metrics;
                const metricsB = analysisData.b.metrics;
                metricsContainer.innerHTML = `
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Key Metrics Comparison (100m Total)</h2>
                    <div class="bg-gray-50 p-6 rounded-lg shadow-inner grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        ${createComparisonTile('Total Time', metricsA.totalTime, metricsB.totalTime, 's', 2)}
                        ${createComparisonTile('Total Strokes', metricsA.strokeCount, metricsB.strokeCount, '', 0)}
                        ${createComparisonTile('Stroke Rate', metricsA.strokeRate, metricsB.strokeRate, 'spm', 1)}
                        ${createComparisonTile('Average Velocity', metricsA.averageVelocity, metricsB.averageVelocity, 'm/s', 2)}
                        ${createComparisonTile('Peak Velocity', metricsA.peakVelocity, metricsB.peakVelocity, 'm/s', 2)}
                        ${createComparisonTile('Stroke Length', metricsA.strokeLength, metricsB.strokeLength, 'm', 2)}
                        ${createComparisonTile('eWPS', metricsA.eWPS, metricsB.eWPS, '', 2)}
                    </div>`;
            }

            // (NEW) Helper for single metric tile
            function createMetricTile(label, value, unit) {
                return `
                    <div class="p-4 bg-white rounded-lg shadow">
                        <span class="font-semibold text-gray-500 block text-sm uppercase">${label}</span>
                        <span class="text-3xl font-bold text-blue-600">${value} ${unit === 's' || unit === 'm/s' || unit === 'spm' || unit === 'm' ? unit : ''}</span>
                        <span class="text-xs text-gray-400 block">${unit !== 's' && unit !== 'm/s' && unit !== 'spm' && unit !== 'm' ? unit : ''}</span>
                    </div>`;
            }

            // (NEW) Helper for comparison metric tile
            function createComparisonTile(label, valueA, valueB, unit, precision) {
                const diff = valueB - valueA;
                const diffSign = diff > 0 ? '+' : '';
                const diffColor = diff > 0 ? 'text-green-600' : (diff < 0 ? 'text-red-600' : 'text-gray-500');
                
                return `
                    <div class="p-4 bg-white rounded-lg shadow">
                        <span class="font-semibold text-gray-500 block text-sm uppercase">${label}</span>
                        <div class="mt-1">
                            <span class="text-2xl font-bold text-blue-600">${valueA.toFixed(precision)} ${unit}</span>
                            <span class="text-gray-400 mx-1">|</span>
                            <span class="text-2xl font-bold text-red-600">${valueB.toFixed(precision)} ${unit}</span>
                        </div>
                        <div class="mt-1 text-lg font-semibold ${diffColor}">
                            ${diffSign}${diff.toFixed(precision)} ${unit}
                        </div>
                    </div>`;
            }

            // (NEW) Single Splits Display
            function displaySingleSplits() {
                const pivotedData = pivotSplitData(analysisData.a.splitMetrics);
                const accordion = document.getElementById('split-accordion');
                accordion.innerHTML = createSplitAccordionHTML(pivotedData, 'a');
                
                // (FIXED) Find first open panel and draw all charts inside it
                const firstOpenPanel = accordion.querySelector('div[id^="split-metric-"]:not(.hidden)');
                if (firstOpenPanel) {
                    firstOpenPanel.querySelectorAll('canvas').forEach(canvas => {
                        const canvasId = canvas.id;
                        if (canvasId && !splitChartInstances.has(canvasId)) {
                            const chartData = JSON.parse(canvas.dataset.chartData);
                            // (UPDATED) Pass datasets array
                            drawSplitChart(canvasId, chartData.labels, chartData.datasets, chartData.unit);
                        }
                    });
                }
            }
            
            // (NEW) Comparison Splits Display
            function displayComparisonSplits() {
                const pivotedDataA = pivotSplitData(analysisData.a.splitMetrics);
                const pivotedDataB = pivotSplitData(analysisData.b.splitMetrics);
                
                const accordion = document.getElementById('split-accordion');
                accordion.innerHTML = createSplitAccordionHTML(pivotedDataA, 'a', pivotedDataB); // Pass both
                
                // (FIXED) Find first open panel and draw all charts inside it
                const firstOpenPanel = accordion.querySelector('div[id^="split-metric-"]:not(.hidden)');
                if (firstOpenPanel) {
                    firstOpenPanel.querySelectorAll('canvas').forEach(canvas => {
                        const canvasId = canvas.id;
                        if (canvasId && !splitChartInstances.has(canvasId)) {
                            const chartData = JSON.parse(canvas.dataset.chartData);
                            // (UPDATED) Pass datasets array
                            drawSplitChart(canvasId, chartData.labels, chartData.datasets, chartData.unit);
                        }
                    });
                }
            }

            // (NEW) Helper to generate accordion HTML for 1 or 2 files
            function createSplitAccordionHTML(pivotedDataA, suffixA, pivotedDataB = null) {
                let allSplitHtml = '';
                splitChartInstances.forEach(chart => chart.destroy());
                splitChartInstances.clear();
                
                let isOpen = true; 
                
                for (const [metricKey, metricInfoA] of Object.entries(pivotedDataA.metrics)) {
                    const contentId = `split-metric-${metricKey}`;
                    
                    const metricInfoB = pivotedDataB ? pivotedDataB.metrics[metricKey] : null;

                    // (NEW) Build chart data based on 1 or 2 files
                    let chartDatasets = [{
                        label: `File A (${analysisData.a.fileInfo.trial})`,
                        data: metricInfoA.data,
                        color: '#3b82f6'
                    }];
                    if (metricInfoB) {
                        chartDatasets.push({
                            label: `File B (${analysisData.b.fileInfo.trial})`,
                            data: metricInfoB.data,
                            color: '#ef4444'
                        });
                    }
                    const chartData = {
                        labels: pivotedDataA.labels,
                        datasets: chartDatasets,
                        unit: metricInfoA.unit
                    };

                    allSplitHtml += `
                        <div class="bg-white rounded-lg shadow-md">
                            <button 
                                data-accordion-toggle="true" 
                                data-accordion-target="${contentId}"
                                class="w-full flex justify-between items-center p-4 font-semibold text-gray-700 hover:bg-gray-50 transition"
                            >
                                <span>${metricInfoA.label}</span>
                                <svg class="w-5 h-5 transition-transform transform ${isOpen ? '' : 'rotate-180'}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </button>
                            
                            <div id="${contentId}" class="p-4 bg-gray-50 border-t border-gray-200 ${isOpen ? '' : 'hidden'}">
                                <!-- (NEW) Single canvas for overlayed chart -->
                                <div class="w-full h-64 mb-4">
                                    <canvas id="chart-metric-${metricKey}" data-chart-data='${JSON.stringify(chartData)}'></canvas>
                                </div>
                                <!-- (NEW) Stacked data tiles -->
                                <div class="split-data-list">
                                    ${pivotedDataA.labels.map((label, index) => createSplitTileHTML(
                                        label, 
                                        metricInfoA.data[index], 
                                        metricInfoA.unit, 
                                        'a',
                                        metricInfoB ? metricInfoB.data[index] : null,
                                        metricInfoB ? metricInfoB.unit : null,
                                        'b'
                                    )).join('')}
                                </div>
                            </div>
                        </div>`;
                    
                    isOpen = false;
                }
                return allSplitHtml;
            }

            // (NEW) Helper to generate the *content* of a split (tiles + chart)
            function createSplitTileHTML(label, valueA, unitA, suffixA, valueB, unitB, suffixB) {
                
                const formatValue = (value, unit) => {
                    if (value === null || isNaN(value)) return 'N/A';
                    if (unit === 'strokes') return value;
                    if (unit === 'spm') return value.toFixed(1);
                    return value.toFixed(2);
                };

                const valueAHtml = `
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-medium text-blue-700">File A:</span>
                        <span class="text-lg font-bold text-blue-600">${formatValue(valueA, unitA)} ${unitA}</span>
                    </div>`;
                
                const valueBHtml = valueB !== null ? `
                    <div class="flex justify-between items-center mt-1 pt-1 border-t border-gray-200">
                        <span class="text-sm font-medium text-red-700">File B:</span>
                        <span class="text-lg font-bold text-red-600">${formatValue(valueB, unitB)} ${unitB}</span>
                    </div>` : '';

                return `
                    <div class="flex-shrink-0 w-40 mr-2 p-3 bg-white rounded-lg shadow-inner">
                        <span class="font-semibold text-gray-500 block text-xs uppercase text-center mb-2">${label}</span>
                        ${valueAHtml}
                        ${valueBHtml}
                    </div>`;
            }
        });
    </script>
</body>
</html>

